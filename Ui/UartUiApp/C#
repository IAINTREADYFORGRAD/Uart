1. $: symbol allows you to use {} to interpolate variables and expressions directly into a string.
   C#: $"Selected port: {selectedPort}"
   C : "Selected port: %s\n", selectedPort

2. wrappanel vs grid
	
	(1) wrappanel
		A. arranges its children in a line (either horizontally or vertically) 
           until the edge of the container is reached, then wraps to the next line or column

		B. e.g.,
			<WrapPanel>
				<Button Content="Button 1"/>
				<Button Content="Button 2"/>
				<Button Content="Button 3"/>
				<Button Content="Button 4"/>
			</WrapPanel>
			
			(A) normally
				+------------+------------+------------+------------+
				|  Button 1  |  Button 2  |  Button 3  |  Button 4  |
				+------------+------------+------------+------------+

			(B) If the panel¡¦s width isn't wide enough, it wraps
				+------------+------------+
				|  Button 1  |  Button 2  |
				+------------+------------+
				|  Button 3  |  Button 4  |
				+------------+------------+

	(2) grid
		A. arrange child elements in a tabular form (rows and columns)

		B. e.g.,
			<Grid>
				<Grid.RowDefinitions>
					<RowDefinition Height="Auto"/>
					<RowDefinition Height="Auto"/>
				</Grid.RowDefinitions>
				<Grid.ColumnDefinitions>
					<ColumnDefinition Width="Auto"/>
					<ColumnDefinition Width="Auto"/>
				</Grid.ColumnDefinitions>

				<Button Grid.Row="0" Grid.Column="0" Content="Button 1"/>
				<Button Grid.Row="0" Grid.Column="1" Content="Button 2"/>
				<Button Grid.Row="1" Grid.Column="0" Content="Button 3"/>
				<Button Grid.Row="1" Grid.Column="1" Content="Button 4"/>
			</Grid>
			
			+------------+------------+
			|  Button 1  |  Button 2  |
			+------------+------------+
			|  Button 3  |  Button 4  |
			+------------+------------+

3. static
	(1) if you have a static property in a class that you want to use directly in XAML, 
		you would use {x:Static}.
	
	(2) e.g.,

		public static class Converters
		{
			public static readonly X1Converter X1ConverterInstance = new X1Converter();
		}

		 <Grid>
			<Canvas>
				<Line X1="{Binding ElementName=rts1, Path=ActualWidth, Converter={x:Static local:Converters.X1ConverterInstance}}"
					  Stroke="LightBlue" StrokeThickness="2" />
			</Canvas>
		</Grid>

4. why we need to add 'converter' to resources in xaml but 'eventhandler' does not
		
	(1) event handler
			
		A. Build Time Resolution: When you declare an event handler in XAML (e.g., SelectionChanged="comboBoxPorts_SelectionChanged1"), 
									the WPF compiler wires this up at build time. 
									It looks for the corresponding method in the code-behind (MainWindow.xaml.cs).
			
		B. Direct Reference: The event handler is directly referenced in the XAML markup, 
								and because this reference is resolved at build time, 
								WPF can easily link the XAML with the code-behind.

		C. Container: The XAML elements, like ComboBox, provide a "container" for event handlers. 
					  These are predefined properties that expect method names (event handlers) from the code-behind.
					  e.g., ComboBox SelectionChanged="comboBoxPorts_SelectionChanged1"

	(2) converter

		A. Runtime Resolution: Converters are used in data bindings, which are resolved at runtime. 
						       The XAML engine needs to know where to find the converter object when it evaluates a binding expression.

		B. Resource System: resource system in WPF is designed to provide objects (like converters) to the binding engine at runtime

		C. No Direct Container: Unlike event handlers,
								there is no direct "container" for converters in XAML elements. 
								Instead, converters are referenced indirectly through bindings, 
								and the resource system is responsible for resolving these references.

	(3) conclusion
		
		A. Event Handlers: The reference is established during the build process, linking the XAML to code-behind.

		B. Converters: The reference is established at runtime, requiring the resource system to supply the converter when needed.

5. WPF

	(1) Windows Presentation Foundation

6. XAML: eXtensible Application Markup Language

7. XAML markup: XML-based syntax used to define the user interface elements, layout, and behavior in a WPF

8. partial class
	
	(1) A partial class can be spread across multiple files. 
		Each file can contain part of the class's definition, 
		and when compiled, the parts are combined into a single class.

	(2) All parts of the partial class must have the same name and must be in the same namespace.

	(3) All parts of the partial class must have the same access modifiers

	(4) Partial classes are commonly used in scenarios where some parts of the class are auto-generated, 
		and other parts are written by the developer.

	(5) e.g.,
		
		// File1.cs                                                      // File2.cs
		namespace MyNamespace											 namespace MyNamespace
		{																 {
			public partial class MyClass									 public partial class MyClass
			{																 {
				public void Method1()											 public void Method2()
				{																 {
					Console.WriteLine("Method1 from File1");						 Console.WriteLine("Method2 from File2");
				}																 }
			}																 }
		}																 }

		class Program
		{
			static void Main(string[] args)
			{
				MyClass myClass = new MyClass();
				myClass.Method1();  // Output: Method1 from File1
				myClass.Method2();  // Output: Method2 from File2
			}
		}